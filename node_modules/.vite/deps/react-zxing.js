import {
  BrowserMultiFormatReader,
  DecodeHintType_default,
  Result_default
} from "./chunk-346X4BRS.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/react-zxing/lib/esm/useZxing.js
var import_react3 = __toESM(require_react());

// node_modules/react-zxing/lib/esm/constants.js
var DEFAULT_CONSTRAINTS = {
  audio: false,
  video: { facingMode: "environment" }
};
var DEFAULT_TIME_BETWEEN_DECODING_ATTEMPTS = 300;

// node_modules/react-zxing/lib/esm/useBrowserMultiFormatReader.js
var import_react = __toESM(require_react());
var useBrowserMultiFormatReader = function(_a) {
  var _b = _a === void 0 ? {} : _a, _c = _b.timeBetweenDecodingAttempts, timeBetweenDecodingAttempts = _c === void 0 ? DEFAULT_TIME_BETWEEN_DECODING_ATTEMPTS : _c, hints = _b.hints;
  return (0, import_react.useMemo)(function() {
    var instance = new BrowserMultiFormatReader(hints);
    instance.timeBetweenDecodingAttempts = timeBetweenDecodingAttempts;
    return instance;
  }, [hints, timeBetweenDecodingAttempts]);
};

// node_modules/react-zxing/lib/esm/useTorch.js
var import_react2 = __toESM(require_react());
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var useTorch = function(_a) {
  var resetStream = _a.resetStream;
  var _b = (0, import_react2.useState)(false), isOn = _b[0], setIsOn = _b[1];
  var _c = (0, import_react2.useState)(null), isAvailable = _c[0], setIsAvailable = _c[1];
  var videoTrackRef = (0, import_react2.useRef)(null);
  var resetStreamRef = (0, import_react2.useRef)(resetStream);
  var init = (0, import_react2.useCallback)(function(videoTrack) {
    videoTrackRef.current = videoTrack;
    setIsAvailable(typeof videoTrack.getCapabilities === "function" ? videoTrack.getCapabilities().torch !== void 0 : false);
  }, []);
  var on = (0, import_react2.useCallback)(function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!videoTrackRef.current || !isAvailable)
              return [
                2
                /*return*/
              ];
            return [4, videoTrackRef.current.applyConstraints({
              advanced: [{ torch: true }]
            })];
          case 1:
            _a2.sent();
            setIsOn(true);
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [isAvailable]);
  var off = (0, import_react2.useCallback)(function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!videoTrackRef.current || !isAvailable)
              return [
                2
                /*return*/
              ];
            videoTrackRef.current = null;
            setIsAvailable(null);
            setIsOn(false);
            return [4, resetStreamRef.current()];
          case 1:
            _a2.sent();
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [isAvailable]);
  (0, import_react2.useEffect)(function() {
    resetStreamRef.current = resetStream;
  }, [resetStream]);
  return { init, isOn, isAvailable, on, off };
};

// node_modules/react-zxing/lib/esm/utils.js
var deepCompareObjects = function(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
};

// node_modules/react-zxing/lib/esm/useZxing.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useZxing = function(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.paused, paused = _a === void 0 ? false : _a, hints = options.hints, timeBetweenDecodingAttempts = options.timeBetweenDecodingAttempts, _b = options.onDecodeResult, onDecodeResult = _b === void 0 ? function() {
  } : _b, _c = options.onDecodeError, onDecodeError = _c === void 0 ? function() {
  } : _c, _d = options.onError, onError = _d === void 0 ? function() {
  } : _d;
  var deviceId = "deviceId" in options ? options.deviceId : void 0;
  var _e = (0, import_react3.useState)("constraints" in options ? options.constraints : void 0), constraints = _e[0], setConstraints = _e[1];
  var decodeResultHandlerRef = (0, import_react3.useRef)(onDecodeResult);
  var decodeErrorHandlerRef = (0, import_react3.useRef)(onDecodeError);
  var errorHandlerRef = (0, import_react3.useRef)(onError);
  var ref = (0, import_react3.useRef)(null);
  var reader = useBrowserMultiFormatReader({
    hints,
    timeBetweenDecodingAttempts
  });
  var _f = useTorch({
    resetStream: function() {
      return __awaiter2(void 0, void 0, void 0, function() {
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              stopDecoding();
              return [4, startDecoding()];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
  }), torchInit = _f.init, torch = __rest(_f, ["init"]);
  var decodeCallback = (0, import_react3.useCallback)(function(result, error) {
    if (result)
      decodeResultHandlerRef.current(result);
    if (error)
      decodeErrorHandlerRef.current(error);
  }, []);
  var startDecoding = (0, import_react3.useCallback)(function() {
    return __awaiter2(void 0, void 0, void 0, function() {
      var e_1, mediaStream, videoTrack;
      return __generator2(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!ref.current)
              return [
                2
                /*return*/
              ];
            if (paused)
              return [
                2
                /*return*/
              ];
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 6, , 7]);
            if (!deviceId) return [3, 3];
            return [4, reader.decodeFromVideoDevice(deviceId, ref.current, decodeCallback)];
          case 2:
            _a2.sent();
            return [3, 5];
          case 3:
            return [4, reader.decodeFromConstraints(constraints !== null && constraints !== void 0 ? constraints : DEFAULT_CONSTRAINTS, ref.current, decodeCallback)];
          case 4:
            _a2.sent();
            _a2.label = 5;
          case 5:
            return [3, 7];
          case 6:
            e_1 = _a2.sent();
            errorHandlerRef.current(e_1);
            return [
              2
              /*return*/
            ];
          case 7:
            if (!ref.current)
              return [
                2
                /*return*/
              ];
            mediaStream = ref.current.srcObject;
            videoTrack = mediaStream.getVideoTracks()[0];
            if (videoTrack)
              torchInit(videoTrack);
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [reader, deviceId, constraints, paused, decodeCallback, torchInit]);
  var stopDecoding = (0, import_react3.useCallback)(function() {
    reader.reset();
  }, [reader]);
  (0, import_react3.useEffect)(function() {
    decodeResultHandlerRef.current = onDecodeResult;
  }, [onDecodeResult]);
  (0, import_react3.useEffect)(function() {
    decodeErrorHandlerRef.current = onDecodeError;
  }, [onDecodeError]);
  (0, import_react3.useEffect)(function() {
    errorHandlerRef.current = onError;
  }, [onError]);
  (0, import_react3.useEffect)(function() {
    var isConstraintsValueSame = deepCompareObjects(constraints, options.constraints);
    if (!isConstraintsValueSame) {
      setConstraints(options.constraints);
    }
  }, [constraints, options]);
  (0, import_react3.useEffect)(function() {
    startDecoding();
    return function() {
      stopDecoding();
    };
  }, [startDecoding, stopDecoding]);
  return {
    ref,
    torch
  };
};
export {
  DecodeHintType_default as DecodeHintType,
  Result_default as Result,
  useZxing
};
//# sourceMappingURL=react-zxing.js.map
